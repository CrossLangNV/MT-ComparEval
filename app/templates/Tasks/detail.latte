{block scripts}
{include #parent}
<script type="text/javascript" src="{$baseUri}/js/ngrams.js"></script>
<script type="text/javascript">

angular.module('scroll', []).directive('whenScrolled', function() {
	return function(scope, elm, attr) {
		var raw = elm[0];

		$(window).bind('scroll', function() {
			var elementBottom = $(raw).offset().top + $(raw).height();
			var windowBottom = $(window).scrollTop() + $(window).height();	

			if( elementBottom <= windowBottom ) {
				scope.$apply( attr.whenScrolled );
			}
		});
	};
});

function Sentences( $scope, $http ) {
	$scope.sentences = [];
	$scope.offset = 0;
	$scope.currentMetric = 'rand';
	$scope.order = 'id';
	$scope.asc = true;

	loadSentences();

	$scope.$watch( 'currentMetric+order+asc', reloadSentences );

	function reloadSentences( oldValue, newValue ) {
		if( oldValue == newValue ) {
			return;
		}

		$scope.sentences = [];
		$scope.offset = 0;

		loadSentences();
	}

	$scope.sortSentencesAscending = function() {
		$scope.order = 'metric';
		$scope.asc = true;
	}	

	$scope.sortSentencesDescending = function() {
		$scope.order = 'metric';
		$scope.asc = false;
	}	

	$scope.cancelSort = function() {
		$scope.order = 'id';
		$scope.asc = true;
	}

	$scope.loadMore = function() {
		loadSentences();
	}

	function loadSentences() {
		$http.get( '{!$baseUri}/api/sentences', {
			params: {
				{foreach $taskIds as $i => $id}
				"taskIds[{$i}]": {$id},
				{/foreach}
				"offset": $scope.offset,
				"limit": 10,
				"orderBy": ( $scope.order == 'id' ) ? 'id' : $scope.currentMetric,
				"order": ( $scope.asc ) ? 'asc' : 'desc'
			}
		} ).success( addSentences );
	}

	function addSentences( data ) {
		data.sentences.forEach( function( sentence ) {
			if( sentence.translations.length == 2 ) {
				metricA = sentence.translations[0].metrics[$scope.currentMetric];
				metricB = sentence.translations[1].metrics[$scope.currentMetric];

				sentence.diff = metricA - metricB;
			}

			sentence.reference_tokens = initClasses( tokenize( sentence.reference ) );
			sentence.translations.forEach( function( translation, translationNumber ) {
				translation.tokens = initClasses( tokenize( translation.text ) );

				var matchingPositions = getMatchingPositions( getNGrams( sentence.reference ), getNGrams( translation.text ) );
				for ( var i in matchingPositions.reference ) {
					if( matchingPositions.reference[i] == true ) {
						sentence.reference_tokens[i].class.push( 'matching-' + translationNumber );
					}
				}

				for ( var i in matchingPositions.translation ) {
					if( matchingPositions.translation[i] == true ) {
						translation.tokens[i].class.push( 'matching-' + translationNumber );
					}
				}
			} );

			var improving = getImproving(
				getNGrams( sentence.reference ),
				[ getNGrams( sentence.translations[0].text ), getNGrams( sentence.translations[1].text ) ]
			);

			var worsening = getWorsening(
				getNGrams( sentence.reference ),
				[ getNGrams( sentence.translations[0].text ), getNGrams( sentence.translations[1].text ) ]
			);
			
			sentence.translations.forEach( function( translation, translationNumber ) {
				improving[ translationNumber ].forEach( function( isImproving, token ) {
					if( isImproving ) {
						translation.tokens[ token ].class.push( 'improving' );
					}
				} );

				worsening[ translationNumber ].forEach( function( isWorsening, token ) {
					if( isWorsening ) {
						translation.tokens[ token ].class.push( 'worsening' );
					}
				} );
			} );

			$scope.sentences.push( sentence );
			$scope.offset++;
		} );
	}

	$scope.predicate = function( sentence ) {
		if( $scope.order == 'id' ) {
			return parseInt( sentence.sentence_id );
		} else if( sentence.translations.length == 1 ) {
			return parseFloat( sentence.translations[0].metrics[$scope.currentMetric] );
		} else {
			var metricA = parseFloat( sentence.translations[0].metrics[$scope.currentMetric] ); 
			var metricB = parseFloat( sentence.translations[1].metrics[$scope.currentMetric] ); 

			return metricA - metricB;
		}
	}
};
</script>
{/block}

{block #content}
<style>
.matching-active .matching-0 {
	background-color: #F89406;
	color: white;
	padding: 0em 0.2em;
}

.matching-active .matching-1 {
	background-color: #006DCC;
	color: white;
	padding: 0em 0.2em;
}

.matching-active .matching-0.matching-1 {
	background-color: #51A351;
	color: white;
	padding: 0em 0.2em;
}

.matching-0.improving {
	background-color: yellow;
}

.matching-1.improving {
	background-color: blue;
}

.worsening {
	background-color: red;
	color: white;
}

</style>
<div ng-app="scroll" ng-controller="Sentences" when-scrolled="loadMore()" class="matching-active">
	<a ng-click="sortSentencesAscending()" id="sort-asc">sort ascending</a>
	<a ng-click="sortSentencesDescending()" id="sort-desc">sort descending</a>
	<a ng-click="cancelSort()" id="sort-cancel">cancel sort</a>

	<select ng-model="currentMetric" id="metrics">
		<option value="bleu">bleu</option>
		<option value="rand">rand</option>
	</select>

	<ul >
		<li
			ng-repeat="sentence in sentences | orderBy:predicate:!asc"
			class="sentence"
			data-id="{{ sentence.sentence_id }}">

			<div class="source">{{ sentence.source }}</div>
			<div class="reference">
				<span ng-repeat="token in sentence.reference_tokens" class="{{ token.class.join( ' ' ) }}"> {{ token.token }} </span>
			</div>

			<div ng-repeat="translation in sentence.translations" class="translation">
				<div class="text">
					<span ng-repeat="token in translation.tokens" class="{{ token.class.join( ' ' ) }}"> {{ token.token }} </span>
				</div>
				<div class="metric">{{ translation.metrics[currentMetric] }}</div>
			</div>
			<strong class="diff-metric">{{ sentence.diff }}</strong>
			<hr><br><br>
		</li>
	</ul>
	<div id="load-next">load next</div>
</div>
{/block}
